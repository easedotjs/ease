{
  "version": 3,
  "sources": ["index.js"],
  "sourcesContent": ["if (typeof ease === 'undefined') {\n  throw new Error('This library requires Ease to be loaded first')\n}\nease.extensions.before(['@easedotjs/components'])\n\nconst { error } = ease.log;\nconst { live } = ease;\n\n// Get the live method from the reactive extension\nlet evals = [];\n\n/**\n * Parses a template string and converts all {{}} to <reactive-text></reactive-text>\n * @param {string} The text content of a <template> tag \n * @returns A string with the text wrapped in <reactive-text></reactive-text>\n */\nfunction onFetchComponent({template}) {\n  // TODO: This could be much cleaner and safer; but possibly slower if we crawl the DOM\n  //       for text nodes.\n  let test = template.innerHTML.replace(/{{(.*?)}}/g, '<reactive-text>$1</reactive-text>');\n  let parser = new DOMParser();\n  let doc = parser.parseFromString(test, 'text/html');\n  template.innerHTML = doc.body.innerHTML;\n}\n\n/**\n * When a component is initialized, this method is called to convert all reactive-text elements to reactive values\n * @param {object} An object containing the shadow root and args \n */\nfunction onInit({ shadow, args }) {\n  // Find all reactive-text elements\n  let reactiveTextElements = shadow.querySelectorAll('reactive-text');\n\n  if (reactiveTextElements.length === 0) return;\n  \n  // Add reactive meta if it does not exist\n  args.rx = args.rx || {};\n\n  // TODO: Make reactive attributes work\n\n  // Convert all reactive-text elements to reactive values\n  reactiveTextElements.forEach((element) => {\n    // Get the key from the text content\n    let key = element.textContent.trim();\n    let textNode = document.createTextNode('');\n    element.parentNode.replaceChild(textNode, element);\n\n    // If the key starts with :, it's bound to an property\n    if (key.startsWith(':')) {\n      key = key.substring(1);\n\n      // If the key exists, bind the reactive value to the property\n      if (!args.properties[key]) {\n        throw error(`Property ${key} does not exist, but is using the property binding syntax :${key}`, \n                    'In component:', shadow.tagName,\n                    'At position:', shadow).toError();\n      }\n\n      args.properties[key]?.watch((value) => {\n        textNode.textContent = value;\n      });\n\n      textNode.textContent = args.properties[key].value;\n    } else if (key.startsWith('[')) {\n      // If the key starts with [, it's an expression\n      // NOTE: This is a very basic implementation and does not support complex expressions\n      //       nor is it reactive. This is a proof of concept.\n      function evaluate() {\n        const expression = key.substring(1, key.length - 1);\n        const path = expression.split('.');\n        \n        const targetPath = path.slice(0,-1).reduce((acc, key) => acc[key], args);\n        let target = path[path.length - 1];\n  \n        if (target.endsWith('()')) { \n          target = target.substring(0, target.length - 2);\n          textNode.textContent = targetPath[target].call(targetPath);\n        } else {\n          textNode.textContent = path.reduce((acc, key) => acc[key], args);\n        }\n      }; evaluate();\n      evals.push(evaluate);\n\n      // Add an update method to rx\n      if (!args.rx.update) {\n        args.rx.update = () => evals.forEach((evaluate) => evaluate());\n      }\n    } else {\n      // If the key does not exist, create a new reactive value\n      if (!args.rx[key]) {\n        args.rx[key] = live();\n      }\n      \n      args.rx[key].subscribe((value) => {\n        textNode.textContent = value.value;\n      });\n    }\n  });  \n}\n\n/**\n * Cleans up reactive values when a component is removed\n */\nfunction onCleanup({args}) {\n  if (args.rx) {\n    Object.keys(args.rx).forEach((key) => {\n      args.rx[key].unsubscribe();\n    })\n  } \n  evals = [];\n}\n\n// ease.extensions.add({\n//   name: '@easedotjs/reactive-dom',\n//   ['@easedotjs/components']: { \n//     onFetchComponent,\n//     onInit,\n//     onCleanup\n//   }\n// });\n"],
  "mappings": "MAAA,GAAI,OAAO,KAAS,IAClB,MAAM,IAAI,MAAM,+CAA+C,EAEjE,KAAK,WAAW,OAAO,CAAC,uBAAuB,CAAC,EAEhD,GAAM,CAAE,MAAAA,CAAM,EAAI,KAAK,IACjB,CAAE,KAAAC,CAAK,EAAI",
  "names": ["error", "live"]
}
