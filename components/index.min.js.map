{
  "version": 3,
  "sources": ["registry.js", "hydrate.js", "index.js"],
  "sourcesContent": ["if (typeof ease === 'undefined') {\n  throw new Error('This library requires Ease to be loaded first')\n}\n\nconst { warn, error, info } = ease.log\nconst { config } = ease\n\n/**\n * The registry of components\n * @type {Map<string, ComponentRegistryDef>}\n */\nconst ComponentRegistry = new Map();\n\n/** \n * Defines an property \n * \n*/\nclass Property {\n  /** @type {string} The name of the property */\n  name;\n  /** @type {string} The type of the property */\n  type;\n  /** @type {string} The default value of the property */\n  default;\n  /** @type {boolean} Whether the property is required */\n  required;\n  /** @type {boolean} Should the property be made available to the style */\n  exposeToStyles;\n  /** @type {boolean} If true, expose this property as an attribute */\n  attribute;\n\n  /**\n   * Creates a new property definition\n   * @param {string} name The name of the property\n   * @param {string} type The type of the property\n   * @param {string} defaultVal The default value of the property\n   * @param {boolean} attribute Should the property be exposed as an attribute\n   * @param {boolean} required Whether the property is required \n   * @param {boolean} exposeToStyles Should the property be made available to the style\n   */\n  constructor(name, type, defaultVal, required, exposeToStyles, attribute) {\n    this.name = name;\n    this.type = type || 'string';\n    this.default = defaultVal;\n    this.required = required;\n    this.attribute = attribute;\n    this.exposeToStyles = exposeToStyles;\n  }\n}\n  \n/**\n * Defines a component to be entered into the registry\n */\nclass ComponentRegistryDef {\n  /** @type {HTMLTemplateElement} The template for the component */\n  template;\n  /** @type {string} The tag name of the component */\n  tagName;\n  /** @type {string} The script body for the component, stored as a Blob */\n  script;\n  /** @type {string} The style for the component */\n  style;\n  /** @type {Property[]} The properties available in the component */\n  properties;\n  /** @type {string} The source of the component */\n  href;\n\n  /**\n   * Creates a new component definition\n   * @param {HTMLTemplateElement} template The template for the component\n   * @param {string} tagName The tag name of the component\n   * @param {string} script The script body for the component\n   * @param {string} style The style for the component\n   * @param {string} properties The properties for the component\n   */\n  constructor(href, template, tagName, script, style, properties) {\n    this.href = href;\n    this.template = template;\n    this.tagName = tagName;\n    this.script = this._scriptBlobFromText(script);\n    this.style = style;\n    this.properties = properties;\n  }\n\n  _scriptBlobFromText(text) {\n    if (!text) return null;\n    const blob = new Blob([text], { type: 'text/javascript' });\n    return URL.createObjectURL(blob);\n  }\n}\n\n/**\n * Fetches a component from a URL and returns a ComponentRegistryDef\n * @param {string} tagName The tag name of the component\n * @param {string} href The URL to fetch the component from\n * @returns {Promise<ComponentRegistryDef>} The component definition\n */\nexport async function fetchComponent(tagName, href) {\n  if (ComponentRegistry.has(tagName)) {\n    const existingItem = ComponentRegistry.get(tagName);\n    if (existingItem.href !== href) {\n      throw error(`Component ${tagName} already exists in the registry with a different href`).toError();\n    }\n    return existingItem;\n  }\n\n  const {template, script, style, properties} = await fetch(href)\n    .then(async (response) => ({ content: await response.text(), code: response.status }))\n    .then(({content, code}) => {\n      if (code !== 200) {\n        throw new Error(`Failed to fetch component from ${href}`);\n      }\n\n      // Parse the document and extract the template, script, and style\n      const parser = new DOMParser();\n      // TODO: Handle parsing errors\n      const document = parser.parseFromString(`${content}`, 'text/html');\n      // TODO: Throw a warning if the document does not contain a template\n      const template = document.querySelector('template') || document.createElement('template');\n      const script = document.querySelector('script:not([src])')?.textContent;\n      const style = document.querySelector('style')?.textContent;\n      const properties = Array.from(document.querySelectorAll('property')).map((prop) => {\n        return new Property(\n          prop.getAttribute('name'), \n          prop.getAttribute('type'), \n          prop.getAttribute('default'), \n          prop.hasAttribute('required'), \n          prop.hasAttribute('expose-to-styles'),\n          prop.hasAttribute('attribute'));\n      });\n\n      // Run the component through extensions\n      ease.extensions.getExtensionsByArtifact('@easedotjs/components').forEach((extension) => {\n        if (extension.onFetchComponent) {\n          extension.onFetchComponent({template, script, style});\n        }\n      });\n\n      return {template, script, style, properties};\n    });\n\n    // Register the component\n    return new ComponentRegistryDef(href, template, tagName, script, style, properties);\n}\n\n/**\n * Registers a component with the registry\n * @param {ComponentRegistryDef} def The component definition\n */\nexport function registerComponent(def) {\n  // TODO: Validate the component definition\n  if (!ComponentRegistry.has(def.tagName)) {\n    ComponentRegistry.set(def.tagName, def);\n  }\n}\n\n/**\n * Fetches a component from the registry\n * @param {string} tagName The tag name of the component\n * @returns \n */\nexport function getComponent(tagName) {\n  return ComponentRegistry.get(tagName);\n}\n\n/**\n * Fetches a component from a link element and registers it, or returns the existing component\n * @param {HTMLLinkElement} link The link element to fetch the component from\n * @returns {Promise<ComponentRegistryDef>} The component definition\n */\nexport async function fetchComponentFromLink(link) {\n  return fetchComponent(link.getAttribute('rel'), link.href)\n    .then((def) => {\n      registerComponent(def);\n      return def;\n    });\n}\n", "if (typeof ease === 'undefined') {\n  throw new Error('This library requires Ease to be loaded first')\n}\n\nimport { getComponent } from './registry.js';\nconst { config, extensions } = ease\nconst { error } = ease.log\n\n/**\n * Creates the class for a web component from the registry\n * @param {ComponentRegistryDef} registryDef The registry definition\n * @returns {typeof HTMLElement} The web component class\n */\nexport function createWebComponentClass(\n  tagName,\n  template,\n  style,\n  scriptUrl,\n  properties,\n) {\n  // TODO: A lot of this code is only needed to be initialized once \n  //       - we should make it static on the class\n  const component = class extends HTMLElement {\n    /** The shadow element that holds the content */\n    _shadow;\n    _mounted = false;\n    _styleEl;\n    _propStyleEl;\n    _eventListeners = [];\n    _args = {\n      // The shadow\n      root: undefined,\n      // Elements\n      elements: {},\n      get el() { return this.elements },\n      // Properties\n      properties: {},\n      get props() { return this.properties },\n      // Extensions\n      extensions: {},\n      get ext() { return this.extensions },\n      get [config.inject.name]() { return this.extensions}\n    };\n\n    constructor() {\n      super();\n\n      // Allows accessing the component from methods\n      let self = this;\n      \n      if (template.hasAttribute('shadowless')) {\n        this._shadow = this;\n      } else {\n        // Create the shadow DOM\n        this._shadow = this.attachShadow({mode: 'open'});\n        this._args.root = this._shadow;\n      }\n\n      // Add tag name to shadow for debugging purposes\n      this._shadow.tagName = tagName;\n          \n      // Clone the template into the shadow DOM\n      this._shadow.appendChild(template.content.cloneNode(true));\n      \n      // Load the stylesheet\n      if (style) {\n        this._styleEl = document.createElement('style');\n        this._styleEl.textContent = style;\n        this._shadow.appendChild(this._styleEl);\n      } \n\n      // Get properties and store them in the properties object\n      let propStyles = '';      \n      properties?.forEach?.((prop) => {        \n        this._args.properties[prop.name] = {\n          _listeners: [],\n          _value: prop.default,\n          type: prop.type,\n          required: prop.required,\n          exposeToStyles: prop.exposeToStyles,\n          attribute: prop.attribute,\n          get value() { return this._value },\n          set value(v) { \n            const prev = this._value;\n            this._value = v;\n            this._listeners.forEach((l) => l(v, prev));\n            if (this.exposeToStyles) self.updateStyles();\n          },\n          /**\n           * Adds a watcher to the property, which receives the current and previous values\n           * This will be invoked on mount and whenever the value changes\n           * @param {function} callback \n           */\n          watch(callback) {\n            this._listeners.push(callback);\n            if (!this._mounted) {\n              callback(this.value, undefined);\n            }\n          },\n          /**\n           * Removes a watcher from the property\n           * @param {function} callback\n           */\n          unwatch(callback) {\n            this._listeners = _listeners.filter((l) => l !== callback);\n          },\n          /**\n           * Removes all watchers from the property\n           */\n          unwatchAll() {\n            this._listeners = [];\n          }\n        };\n        \n        Object.defineProperty(this, prop.name, {\n          get: () => this._args.properties[prop.name].value,\n          set: (v) => { \n            this._args.properties[prop.name].value = v\n          }\n        })\n\n        // If the attribute is required, throw an error if it is not present \n        if (prop.required && prop.attribute && !this.hasAttribute(prop.name)) {\n          throw error(`Attribute ${prop.name} is required`).toError();\n        }\n\n        if (prop.attribute) {\n          this._args.properties[prop.name].value = this.getAttribute(prop.name) || prop.default;\n        }\n\n        // If the property is set for style exposure, add it to the style element\n        if (prop.exposeToStyles) {\n          propStyles += `--${prop.name}: ${this._args.properties[prop.name].value}; `;\n        }\n      });\n\n      // Add the attribute styles to the style element\n      if (propStyles) {\n        this._propStyleEl = document.createElement('style');\n        this._propStyleEl.textContent += `:host { ${propStyles} }`;\n        this._shadow.insertBefore(this._propStyleEl, this._styleEl);\n      }\n\n      // Get elements by ID and store them in the elements object\n      this._shadow.querySelectorAll('[id]').forEach((el) => {\n        this._args.elements[el.id] = el;\n      });\n      \n      // Get all extensions\n      this._args.extensions = extensions.all.reduce((p, c) => {\n        const objects = c.objects || {};\n        const methods = c.methods || {};\n        return {...p, ...objects, ...methods};\n      }, {});\n\n      // Override event listeners; this allows tracking event listeners\n      // and removing them when the component is disconnected\n      const _shadowAddEventListener = this._shadow.addEventListener;\n      this._shadow.addEventListener = function (name, callback) {\n        self._eventListeners.push({ name, callback })\n        _shadowAddEventListener(name, callback)\n      }\n      \n      const _shadowRemoveEventListener = this._shadow.removeEventListener;\n      this._shadow.removeEventListener = function (name, callback) {\n        self._eventListeners = self._eventListeners.filter(({ name: n, callback: c }) => {\n          if (n === name && c === callback) {\n            _shadowRemoveEventListener(name, callback)\n            return false\n          }\n          return true\n        })\n      }\n            \n      // Load the script\n      if (scriptUrl) {\n        import(scriptUrl).then((module) => {\n          if (!module.default) return;          \n          // If the module has a default export, call it with the component as the argument\n          if (module.default) module.default.apply(self, [{...this._args, self }]);\n          \n          // Dispatch a connect event\n          this._shadow.dispatchEvent(new CustomEvent('connect'));\n        });\n      }\n\n      // Handle initialization through extensions\n      extensions.getExtensionsByArtifact('@easedotjs/components').forEach(ext =>\n        ext.onInit?.({ shadow: this._shadow, args: this._args, instance: self })\n      );\n    }\n\n    // Update Styles to reflect attribute changes\n    updateStyles() {\n      if (!this._propStyleEl) return;\n      let propStyles = '';\n      Object.keys(this._args.properties).forEach((key) => {\n        const prop = this?.[key];\n        if (prop.exposeToStyles) {\n          attrStyles += `--${key}: ${prop.value}; `;\n        }\n      });\n      this._propStyleEl.textContent = `:host { ${propStyles} }`;\n    };\n\n    // On connect, add watchers\n    connectedCallback() {\n      this._mounted = true;\n      // Dispatch a connect event\n      this._shadow.dispatchEvent(new CustomEvent('connect'));\n    }\n\n    // On disconnect, remove all watchers\n    disconnectedCallback() {\n      this._mounted = false;\n      this._args.properties?.forEach?.((attr) => {\n        attr.unwatchAll();\n      });\n      this._shadow.dispatchEvent(new CustomEvent('disconnect'));\n\n      // Remove all event listeners\n      this._eventListeners.forEach(({ name, callback }) => {\n        this._shadow.removeEventListener(name, callback)\n      })\n\n      // Handle cleanup through extensions\n      extensions.getExtensionsByArtifact('@easedotjs/components').forEach(ext =>\n        ext.onCleanup?.({ shadow: this._shadow, args: this._args })\n      );\n    }\n\n    static get observedAttributes() {\n      return properties.filter((prop) => prop.attribute).map((attr) => attr.name);\n    }\n  }\n  customElements.define(tagName, component);\n  return component;\n}", "if (typeof ease === 'undefined') {\n  throw new Error('This library requires Ease to be loaded first')\n}\n\nconst { warn, error, info } = ease.log\n\nimport { fetchComponent, registerComponent } from './registry.js'\nimport { createWebComponentClass } from './hydrate.js'\n\n// Get components defined in the document\nconst componentPromises = Array.from(document.querySelectorAll('link[rel=\"component\"]')).map(async (link) => {\n  const def = await fetchComponent(link.getAttribute('name'), link.href);\n  // Register the component\n  registerComponent(def);\n  // Define the custom element\n  createWebComponentClass(def.tagName, def.template, def.style, def.script, def.properties);\n})\n\n// Get component definitions\nconst componentDefPromises = Array.from(document.querySelectorAll('link[rel=\"component-def\"]')).map(async (link) => {\n  return fetch(link.href).then((response) => {\n    if (response.status === 404) {\n      throw warn(`Failed to load component from ${href}`)\n    }\n    return response.text()\n  }).then(async (content) => {\n    // Fetch the component def xml\n    let parser = new DOMParser()\n    let components = parser.parseFromString(content, 'text/xml').querySelector('components')\n    const promises = Array.from(components.childNodes).map(async (component) => {\n      if (component.nodeName === 'component') {\n        await fetchComponent(component.attributes['name'].value, component.attributes['href'].value)\n          .then((def) => {\n            // Register the component\n            registerComponent(def);\n\n            // Define the custom element\n            createWebComponentClass(def.tagName, def.template, def.style, def.script, def.properties);\n          })\n      }\n    })\n    await Promise.all(promises)\n    info(`Loaded component definitions from ${link.href}`)\n  })\n})\n\n// Rehydrate the document if it's wrapped in a template\n// This allows us to defer rendering\nPromise.all([...componentPromises, ...componentDefPromises]).then(() => {\n  const rootTemplate = document.querySelector('body > template');\n  if (rootTemplate) {\n    rootTemplate.replaceWith(rootTemplate.content);\n  }\n});\n\n"],
  "mappings": "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",
  "names": ["warn", "error", "info", "config", "ComponentRegistry", "Property", "name", "type", "defaultVal", "required", "exposeToStyles", "attribute", "ComponentRegistryDef", "href", "template", "tagName", "script", "style", "properties", "text", "blob", "fetchComponent", "existingItem", "response", "content", "code", "document", "prop", "extension", "registerComponent", "def", "config", "extensions", "error", "createWebComponentClass", "tagName", "template", "style", "scriptUrl", "properties", "component", "self", "propStyles", "prop", "v", "prev", "l", "callback", "el", "p", "c", "objects", "methods", "_shadowAddEventListener", "name", "_shadowRemoveEventListener", "n", "module", "ext", "key", "attr", "warn", "error", "info", "componentPromises", "link", "def", "fetchComponent", "registerComponent", "createWebComponentClass", "componentDefPromises", "response", "content", "components", "promises", "component", "rootTemplate"]
}
