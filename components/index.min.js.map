{
  "version": 3,
  "sources": ["index.js"],
  "sourcesContent": ["if (!ease) {\n  throw new Error('This library requires Ease to be loaded first')\n}\n\nconst { warn, error, info } = ease.log\nconst { config } = ease\n\nlet componentRegistry = {}\n\n/**\n * Fetch a component, then parse it into a shared object \n * @param {*} name The name of the component\n * @param {*} href The URL of the component\n * @returns \n */\nasync function fetchComponent(name, href) {\n  let template, script, style, attributes = []\n\n  await fetch(href)\n    .then(async (response) => ({ content: await response.text(), code: response.status }))\n    .then(({content, code}) => {\n      // If the file does not exist, return an error\n      if (code === 404) {\n        template = document.createElement('template');\n        style = document.createElement('style');\n\n        if (config.core.debug) {\n          error(`Failed to load component '${name}' from ${href}`)\n          template.innerHTML = `<div><strong>Ease Component Error:</strong> Failed to load component '${name}' from ${href}</div>`\n          style.innerText = `:host { color: #800; padding: 1rem; }`\n        }\n        return;\n      }\n\n      let parser = new DOMParser()\n      let doc = parser.parseFromString(content, 'text/html')\n      \n      // If the component does not contain template, treat the entire content as the template\n      if (!doc.querySelector('template')) {\n        template = doc.createElement('template')\n        template.innerHTML = content\n        doc.body.appendChild(template)\n      } else {\n        template = doc.querySelector('template')\n        script = doc.querySelector('script:not([src])')\n        style = doc.querySelector('style')\n      }\n\n      // Parse shadow node for attributes\n      let attributeMeta = template.content.querySelectorAll('meta[name=\"attribute\"]')\n      attributeMeta.forEach((attribute) => {\n        let attributeKey = attribute.attributes['content'].value\n        attributes[attributeKey] = { \n          name: attributeKey, \n          default: attribute.attributes['default']?.value,\n          style: !!attribute.attributes['style'],\n        }\n        attribute.remove()\n      })\n  }).catch((err) => {\n    error(`Failed to load component '${name}' from ${href}`, err)\n  })\n\n  return { template, script, style, attributes }\n}\n\n/**\n * Load a component from a link node\n * @param {*} linkNode The link node to load the component from\n */\nasync function loadComponentFromLink(linkNode) {\n  let name = linkNode.attributes['name']?.value\n  let href = linkNode.attributes['href']?.value\n  loadComponent(name, href)\n}\n\n/**\n * Load a component from a name and href\n * @param {*} name \n * @param {*} href \n * @returns \n */\nasync function loadComponent(name, href) {\n  /** Validate component */\n  if (!name) return error(`Component ${linkNode} missing name attribute`)\n  if (!href) return error(`Component '${name}' missing href`)\n  if (!name.includes('-')) return error(`Component '${name}' must contain a hyphen`)\n  if (componentRegistry[name]) return info(`Component '${name}' already exists in registry, skipping load`)\n    \n  /** Load HTML into the registry */\n  let componentDef = await fetchComponent(name, href)\n  if (!componentDef.template) return error(`Component '${name}' missing template`)\n  \n  /** Add component to the registry */\n  componentRegistry[name] = componentDef\n\n  /** Define the custom element */\n  customElements.define(name, class extends HTMLElement {\n    constructor() {\n      super()\n      let registryElement = componentRegistry[name]\n      if (!registryElement) return error(`Component '${name}' not found in registry`)\n\n      // Create our shadow node\n      let shadow = this.attachShadow({ mode: 'open' })\n      this.shadow = shadow\n      \n      // Parse shadow node for links\n      let links = registryElement.template.content.querySelectorAll('link')\n      links.forEach(loadComponentFromLink)\n      links.forEach((link) => link.remove())\n\n      // Append the template to the shadow node\n      shadow.appendChild(registryElement.template.content.cloneNode(true))\n\n      if (registryElement.style) shadow.appendChild(registryElement.style.cloneNode(true))\n      if (registryElement.script) { \n        // Get the contents of the script tag if exists\n        const scriptContent = registryElement.script.textContent\n        const blob = new Blob([scriptContent], { type: 'text/javascript' })\n        const moduleURL = URL.createObjectURL(blob)\n\n        // Capture all elements with an ID\n        let elements = []\n        shadow.querySelectorAll('[id]').forEach((element) => { elements[element.id] = element })\n\n        // Load the module and execute it\n        import(moduleURL).then((module) => {\n          // Ensure the script exists and is not empty\n          if (!module.default && !registryElement.script.attributes['no-warn']) return warn(`Component '${name}' contains script tag but does not export a default. Use the no-warn attribute on the script tag if this is the intended behavior`)\n          if (!module.default && registryElement.script.attributes['no-warn']) return\n\n          // Inject the module with the shadow node and elements\n          // We use names with multiple aliases to make it easier to access\n          // depending on your preferences; more explicit or more verbose.\n          let args = {\n            root: shadow, \n            // Element access\n            el: elements, \n            elements,\n            // Attributes\n            attr: this.attributes,\n            attributes: this.attributes,\n            // Extensions\n            extensions: {},\n            get ex () { return this.extensions },\n            get [config.inject.name] () { return this.extensions }\n          }          \n\n          // Inject extensions\n          config.inject.extensions.forEach((extension) => {\n            // Add methods to the extensions\n            extension.methods?.forEach?.((method) => { \n              if (args.extensions[method.name])  {\n                return warn(`Extension method '${method.name}' already exists in extensions, skipping`)\n              }\n              args.extensions[method.name] = method\n            })\n            // Add objects to the extensions\n            args.extensions = {...args.extensions, ...extension.objects}\n          })\n          \n          // Execute the module\n          module.default(args)\n        });\n\n        // Dispatch attributeChanged event for initial state and handle CSS variables\n        let cssVars = {}\n        Object.keys(registryElement.attributes).forEach((key) => {\n          let attribute = registryElement.attributes[key] \n          this.shadow.dispatchEvent(new CustomEvent('attributeChanged', { detail: {name: attribute, oldValue: null, newValue: this.getAttribute(attribute) }}))\n\n          // If the attribute is exposed to CSS, update the CSS variable\n          if (attribute.style && this.getAttribute(attribute.name)) {\n            cssVars[attribute.name] = this.getAttribute(attribute.name)\n          }\n        })\n\n        // Apply CSS variables\n        if (Object.keys(cssVars).length > 0) {\n          let style = document.createElement('style')\n          let css = ':host {'\n          Object.keys(cssVars).forEach((key) => {\n            css += `--${key}: ${cssVars[key]};`\n          })\n          css += '}'\n          style.innerHTML = css\n          shadow.appendChild(style)\n        }\n      \n      }\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      this.shadow.dispatchEvent(new CustomEvent('attributeChanged', { detail: {name, oldValue, newValue}} ))\n    }\n\n    static get observedAttributes() {\n      return Object.values(componentRegistry[name].attributes)\n    }\n  })\n}\n\n/** If the body is replaced, scan for updated links */\ndocument.addEventListener('ease_load_component', (event) => {\n  if (event.detail.name) {\n    loadComponent(event.detail.name, event.detail.href)\n  }\n})\n\n/** Get all component imports */\nlet components = document.querySelectorAll(['link[rel=\"component\"]'])\nif (components) {  \n\n  /** Load all components */\n  components.forEach(loadComponentFromLink)\n} else warn('No components found')\n"],
  "mappings": "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",
  "names": ["warn", "error", "info", "config", "componentRegistry", "fetchComponent", "name", "href", "template", "script", "style", "attributes", "response", "content", "code", "doc", "attribute", "attributeKey", "err", "loadComponentFromLink", "linkNode", "loadComponent", "componentDef", "registryElement", "shadow", "links", "link", "scriptContent", "blob", "moduleURL", "elements", "element", "module", "args", "extension", "method", "cssVars", "key", "css", "oldValue", "newValue", "event", "components"]
}
