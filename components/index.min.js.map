{
  "version": 3,
  "sources": ["index.js"],
  "sourcesContent": ["if (typeof ease === 'undefined') {\n  throw new Error('This library requires Ease to be loaded first')\n}\n\nconst { warn, error, info } = ease.log\nconst { config } = ease\n\nlet componentRegistry = {}\n\n/**\n * Fetch a component, then parse it into a shared object \n * @param {*} name The name of the component\n * @param {*} href The URL of the component\n * @returns \n */\nasync function fetchComponent(name, href) {\n  let template, script, style, attributes = [], src\n\n  await fetch(href)\n    .then(async (response) => ({ content: await response.text(), code: response.status }))\n    .then(({content, code}) => {\n      // If the file does not exist, return an error\n      if (code === 404 || code === 0) {\n        template = document.createElement('template');\n        style = document.createElement('style');\n\n        if (config.core.debug) {\n          error(`Failed to load component '${name}' from ${href}`)\n          template.innerHTML = `<div><strong>Ease Component Error:</strong> Failed to load component '${name}' from ${href}</div>`\n          style.innerText = `:host { color: #800; padding: 1rem; }`\n        }\n        return;\n      }\n\n      // Execute extensions that modify the content\n      ease.extensions.all.forEach((extension) => {\n        if (extension['@easedotjs/components']?.parseTemplate) {\n          content = extension['@easedotjs/components'].parseTemplate(content)\n        }\n      })\n\n      // Parse the content into a document\n      let parser = new DOMParser()\n      let doc = parser.parseFromString(content, 'text/html')\n      \n      // If the component does not contain template, treat the entire content as the template\n      if (!doc.querySelector('template')) {\n        template = doc.createElement('template')\n        template.innerHTML = content\n        doc.body.appendChild(template)\n      } else {\n        template = doc.querySelector('template')\n        script = doc.querySelector('script:not([src])')\n        style = doc.querySelector('style')\n      }\n\n      // Parse shadow node for attributes\n      let attributeMeta = template.content.querySelectorAll('meta[name=\"attribute\"]')\n      attributeMeta.forEach((attribute) => {\n        let attributeKey = attribute.attributes['content'].value\n        attributes[attributeKey] = { \n          name: attributeKey, \n          default: attribute.attributes['default']?.value,\n          style: !!attribute.attributes['style'],\n        }\n        attribute.remove()\n      })\n  }).catch((err) => {\n    error(`Failed to load component '${name}' from ${href}`, err)\n  })\n\n  // Cache the script blob\n  if (script) {\n    const scriptContent = script.textContent\n    const blob = new Blob([scriptContent], { type: 'text/javascript' })\n    script = URL.createObjectURL(blob)\n  }\n\n  return { template, script, style, attributes, src: href }\n}\n\n/**\n * Load a component from a link node\n * @param {*} linkNode The link node to load the component from\n */\nasync function loadComponentFromLink(linkNode) {\n  let name = linkNode.attributes['name']?.value\n  let href = linkNode.attributes['href']?.value\n  return loadComponent(name, href)\n}\n\n/**\n * Load a component from a name and href\n * @param {*} name \n * @param {*} href \n * @returns \n */\nasync function loadComponent(name, href) {\n  /** Validate component */\n  if (!name) return error(`Component ${linkNode} missing name attribute`)\n  if (!href) return error(`Component '${name}' missing href`)\n  if (!name.includes('-')) return error(`Component '${name}' must contain a hyphen`)\n  if (componentRegistry[name]) {\n    if (componentRegistry[name].src === href) {\n      return info(`Component '${name}' already exists in registry`)\n    } else {\n      return error(\n        `Component '${name}' already exists in registry with a different source`, \n        `Existing component: ${componentRegistry[name].src}`, \n        `New component: ${href}`,\n        'This will cause the existing component to be used instead of the new component',\n        'If you are using a router or other dynamic loading, try using different namespaces for components')\n    }\n  }\n\n  /** Load HTML into the registry */\n  let componentDef = await fetchComponent(name, href)\n  if (!componentDef.template) return error(`Component '${name}' missing template`)\n  \n  /** Add component to the registry */\n  componentRegistry[name] = componentDef\n\n  /** Define the custom element */\n  customElements.define(name, class extends HTMLElement {\n    attributes = {}\n    eventListeners = []\n    onUnload = undefined\n    args = { test: 2 }\n\n    constructor() {\n      super()\n      let registryElement = componentRegistry[name]\n      if (!registryElement) return error(`Component '${name}' not found in registry`)\n\n      // Create our shadow node\n      let shadow = this.attachShadow({ mode: 'open' })\n      this.shadow = shadow\n      \n      // Parse shadow node for links\n      let links = registryElement.template.content.querySelectorAll('link')\n      links.forEach(loadComponentFromLink)\n      links.forEach((link) => link.remove())\n\n      // Append the template to the shadow node\n      shadow.appendChild(registryElement.template.content.cloneNode(true))\n\n      if (registryElement.style) shadow.appendChild(registryElement.style.cloneNode(true))\n\n      // TODO: Some of this depends on the script tag existing, when it shouldn't matter\n      if (registryElement.script) { \n        // Get the contents of the script tag if exists\n        const moduleURL = registryElement.script\n\n        // Capture all elements with an ID\n        let elements = []\n        shadow.querySelectorAll('[id]').forEach((element) => { elements[element.id] = element })\n\n        // Load the module and execute it\n        import(moduleURL).then((module) => {\n          // Ensure the script exists and is not empty\n          if (!module.default && !registryElement.script.attributes['no-warn']) return warn(`Component '${name}' contains script tag but does not export a default. Use the no-warn attribute on the script tag if this is the intended behavior`)\n          if (!module.default && registryElement.script.attributes['no-warn']) return\n\n          // Inject the module with the shadow node and elements\n          // We use names with multiple aliases to make it easier to access\n          // depending on your preferences; more explicit or more verbose.\n          this.args = {\n            root: shadow, \n            // Element access\n            elements,\n            get el () { return this.elements }, \n            // Attributes\n            attributes: [],\n            get attr () { return this.attributes },\n            // Extensions\n            extensions: {},\n            get ext () { return this.extensions },\n            get [config.inject.name] () { return this.extensions }\n          }          \n\n          // Inject extensions\n          config.inject.extensions.forEach((extension) => {\n            // Ensure the extension has methods\n            if (extension.methods) {            \n              // Add methods to the extensions\n              Object.keys(extension.methods)?.forEach?.((method) => { \n                if (extension[method])  {\n                  return warn(`Extension method '${method.name}' already exists in extensions, skipping`)\n                }\n                this.args.extensions[method] = extension.methods[method]\n              })\n            }\n\n            // Add objects to the extensions\n            Object.assign(this.args.extensions, extension.objects)\n          })\n\n          // Inject attributes\n          Object.keys(registryElement.attributes).forEach((key) => {\n            let attribute = registryElement.attributes[key]\n            this.attributes[attribute.name] = {\n              listeners: [],\n              _value: this.getAttribute(attribute.name) || attribute.default,\n              set value(newValue) {\n                let oldValue = this._value\n                this._value = newValue\n                this.listeners.forEach((listener) => listener(newValue, oldValue))\n                shadow.dispatchEvent(new CustomEvent('attribute-changed', { detail: {name: attribute.name, oldValue: oldValue, newValue: newValue }}))\n              },\n              get value() {\n                return this._value\n              },              \n              watch(listener) {\n                this.listeners.push(listener)\n                listener(this.value, null)\n              },\n              unwatch(listener) {\n                this.listeners = this.listeners.filter((l) => l !== listener)\n              },\n              unwatchAll() {\n                this.listeners = []\n              }\n            }            \n          })\n          this.args.attributes = this.attributes\n          \n          // Handle post-parsing extensions\n          ease.extensions.all.forEach((extension) => {\n            if (extension['@easedotjs/components']?.onInit) {\n              extension['@easedotjs/components'].onInit({ shadow, args: this.args })\n            }\n          })\n\n          // Execute the module\n          setTimeout(() => {\n            this.onUnload = module.default(this.args)\n          })\n        });\n\n        // Dispatch attributeChanged event for initial state\n        Object.keys(registryElement.attributes).forEach((key) => {\n          let attribute = registryElement.attributes[key]\n          this.shadow.dispatchEvent(new CustomEvent('attribute-changed', { detail: {name: attribute, oldValue: null, newValue: this.getAttribute(attribute) }}))\n        })\n        \n      }\n\n      // Handle CSS variables\n      let cssVars = {}\n      Object.keys(registryElement.attributes).forEach((key) => {\n        let attribute = registryElement.attributes[key]\n        if (attribute.style && this.getAttribute(attribute.name)) {\n          cssVars[attribute.name] = this.getAttribute(attribute.name)\n        }\n      })\n\n      // Apply CSS variables\n      if (Object.keys(cssVars).length > 0) {\n        let style = document.createElement('style')\n        let css = ':host {'\n        Object.keys(cssVars).forEach((key) => {\n          css += `--${key}: ${cssVars[key]};`\n        })\n        css += '}'\n        style.innerHTML = css\n        shadow.appendChild(style)\n      }      \n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      // Update the attribute value\n      if (this.attributes[name]) {\n        this.attributes[name].value = newValue\n      }\n    }\n\n    addEventListener(name, callback) {\n      // Add the event listener to the shadow node and store it\n      this.eventListeners.push({ name, callback })\n      this.shadow.addEventListener(name, callback)\n    }\n\n    removeEventListener(name, callback) {\n      // Remove the event listener from the shadow node\n      this.eventListeners = this.eventListeners.filter((listener) => {\n        if (listener.name === name && listener.callback === callback) {\n          this.shadow.removeEventListener(name, callback)\n          return false\n        }\n        return true\n      })\n    }\n\n    disconnectedCallback() {\n      // Ensure the component has been initialized before unloading\n      if (this.args) {\n        // Execute the onUnload method if it exists\n        this.onUnload?.(this.args)\n\n        // Remove all event listeners\n        this.eventListeners.forEach((listener) => {\n          this.shadow.removeEventListener(listener.name, listener.callback)\n        })\n\n        // Execute the onCleanup method in extensions that have it\n        ease.extensions.all.forEach((extension) => {\n          if (extension['@easedotjs/components']?.onCleanup) {\n            extension['@easedotjs/components'].onCleanup({ shadow: this.shadow, args: this.args })\n          }\n        })\n\n        // Unwatch all attributes\n        if (this.args && this.args.attributes) {\n          Object.keys(this.args.attributes).forEach((attribute) => {\n            this.args.attributes[attribute].unwatchAll()\n          });\n        }\n      }\n    }\n\n    static get observedAttributes() {\n      return Object.keys(componentRegistry[name].attributes)\n    }\n  })\n}\n\nfunction loadComponentDef(href) {\n  fetch(href).then((response) => {\n    if (response.status === 404) {\n      throw warn(`Failed to load component from ${href}`)\n    }\n    return response.text()\n  }).then((content) => {\n    let parser = new DOMParser()\n    let components = parser.parseFromString(content, 'text/xml').querySelector('components')\n    components.childNodes.forEach((component) => {\n      if (component.nodeName === 'component') {\n        loadComponent(component.attributes['name'].value, component.attributes['href'].value)\n      }\n    })\n  })\n}\n\n// TODO: Consider a better way to handle this\n/** If the body is replaced, scan for updated links */\ndocument.addEventListener('ease_load_component', (event) => {\n  if (event.detail.name) {\n    loadComponent(event.detail.name, event.detail.href)\n  }\n})\n\n/** Get all component imports and load them */\ndocument.addEventListener('DOMContentLoaded', () => {\n  \n  let components = document.querySelectorAll(['link[rel=\"component\"]'])\n  if (components) {  \n    /** Load all components */\n    components.forEach(loadComponentFromLink)\n  }\n\n  let componentDefs = document.querySelectorAll(['link[rel=\"component-def\"]'])\n  if (componentDefs) {\n    componentDefs.forEach((link) => {\n      loadComponentDef(link.attributes['href'].value)\n    })\n  }\n\n  if (!components && !componentDefs) {\n    warn('No components found in document')\n  }\n});\n"],
  "mappings": "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",
  "names": ["warn", "error", "info", "config", "componentRegistry", "fetchComponent", "name", "href", "template", "script", "style", "attributes", "src", "response", "content", "code", "extension", "doc", "attribute", "attributeKey", "err", "scriptContent", "blob", "loadComponentFromLink", "linkNode", "loadComponent", "componentDef", "registryElement", "shadow", "links", "link", "moduleURL", "elements", "element", "module", "method", "key", "newValue", "oldValue", "listener", "l", "cssVars", "css", "callback", "loadComponentDef", "component", "event", "components", "componentDefs"]
}
