{
  "version": 3,
  "sources": ["log.js", "event-bridge.js", "index.js"],
  "sourcesContent": ["import { config } from './index.js'\n\nexport function error(...data) {\n  if (!config.core?.debug) return;\n  console.group('[Error] Ease:');\n  console.error(...data);\n  console.groupEnd();\n}\n\nexport function warn(...data) {\n  if (!config.core?.debug) return;\n  console.group('[Warn] Ease:');\n  console.warn(...data);\n  console.groupEnd();\n}\n\nexport function log(...data) {\n  if (!config.core?.debug) return;\n  console.group('[Log] Ease:');\n  console.log(...data);\n  console.groupEnd();\n}\n\nexport function info(...data) {\n  if (!config.core?.debug || config.core.debug !== 'verbose') return;\n  console.group('Ease:');\n  console.info(...data);\n  console.groupEnd();\n}\n", "/*** \n * Event Bridge\n * ============\n * A simpler interface for sending/receiving events.\n * While this utilizes the browser's built-in EventTarget, it simplifies the \n * process of sending and receiving events by providing a more intuitive API.\n * \n * In addition, this modules provides a mechanism to request objects from\n * anywhere without polluting the global scope.\n * \n * It's highly recommended to namespace your events to avoid conflicts.\n */\n\nimport { error } from './log.js'\n\nlet emitter = new EventTarget()\nlet fetchHandlerIds = []\n\n/**\n * EventBridgeEvent is a custom event that handles simplified event dispatching.\n */\nclass EventBridgeEvent extends CustomEvent {\n  constructor(name, data) {\n    super(`event-bridge--${name}`, { detail: { data } })\n  }\n}\n\n/**\n * EventBridgeFetchEvent is a custom event that facilitates requesting data\n * from anywhere as long as the event is registered.\n * If a response is not provided, the event is a request.\n * If a response is provided, the event is a response to a request.\n */\nclass EventBridgeFetchEvent extends CustomEvent {\n  constructor(name, response) {\n    let _name = response ? \n      `event-bridge-fetch-response--${name}` : \n      `event-bridge-fetch-request--${name}`\n    super(_name, { detail: { response } })\n  }\n}\n\n/**\n * Dispatches an event with the given name and data.\n * @param {string} name The name of the event \n * @param {object} data Additional data to send with the event \n */\nexport function send(name, data) {\n  emitter.dispatchEvent(new EventBridgeEvent(name, data))\n}\n\n/**\n * Listen for an event with the given name.\n * @param {string} name The name of the event to listen for\n * @param {function} callback The method to invoke when the event is fired \n * @returns an object with an off method to remove the event listener\n */\nexport function on(name, callback) {\n  emitter.addEventListener(`event-bridge--${name}`, (event) => {\n    callback?.(event.detail.data)\n  })\n  return {\n    off: () => emitter.removeEventListener('ease-event-bridge', callback)\n  }\n}\n\n/**\n * Listen for a fetch event with the given name.\n * @param {string} name The name of the event to listen for\n * @param {object|function} response A response object or callback method\n * @returns an object with an off method to remove the event listener\n */\nexport function onFetch(name, response) {\n  fetchHandlerIds.push(name)\n  emitter.addEventListener(`event-bridge-fetch-response--${name}`, (event) => {\n    if (typeof response === 'function') {\n      emitter.dispatchEvent(new EventBridgeFetchEvent(name, response))\n    } else if (typeof response === 'boolean') {\n      emitter.dispatchEvent(new EventBridgeFetchEvent(name, true))\n    } else if (typeof response === 'undefined') {\n      error(`onFetch requires a response object or callback method, but none was provided.`)\n    } else {\n      emitter.dispatchEvent(new EventBridgeFetchEvent(name, response))\n    }\n  })\n  return {\n    off: () => {\n      fetchHandlerIds = fetchHandlerIds.filter((id) => id !== name)\n      emitter.removeEventListener('ease-event-bridge-fetch', callback)\n    }\n  }\n}\n\n/**\n * Listen for an event with the given name, but only once.\n * @param {string} name The name of the event to listen for\n * @param {function} callback The method to invoke when the event is fired\n */\nexport function once(name, callback) {\n  return on(name, (data) => {\n    handler.off()\n    callback(data)\n  })\n}\n\n/**\n * Fetches data from an event with the given name.\n * @param {string} name The name of the event to fetch\n * @returns the data from the event\n */\nexport function fetch(name) {\n  return new Promise((resolve, reject) => {\n    if (!fetchHandlerIds.includes(name)) {\n      error(`No fetch handler found for '${name}'`)\n      reject()\n    }\n  \n    emitter.addEventListener(`event-bridge-fetch-response--${name}`, (event) => {\n      resolve(event.detail.response)\n    })\n    \n    emitter.dispatchEvent(new EventBridgeFetchEvent(name))\n  });\n}\n\n/* Add to global allowing any and all modules to access the EventBridge\n * In the future, this will allow other modules to function in the \n * absence of the Ease framework.\n */\nglobalThis.EventBridge = { send, on, onFetch, once, fetch }", "/** Ease */\nimport * as log from './log.js'\nimport { onFetch } from './event-bridge.js'\n\n/* Core Config */\nexport let config = {\n  core: {\n    debug: false, // Enables debug mode; prints errors to console\n  },\n  inject: { // Handles injected extensions\n    name: '$',\n    extensions: []\n  }\n}\n\n/* Parse meta tags for configs */\ndocument.querySelectorAll('meta')?.forEach((meta) => {\n  if (meta.name.startsWith('ease.')) {\n    let path = meta.name.replace('ease.', '').split('.')\n    let key = path.pop()    \n\n    let target = path.reduce((acc,key) => {\n      if (acc[key] === undefined) acc[key] = {}\n      return acc[key]\n    }, config)\n\n    target[key] = meta.content\n  }\n})\n\n/**\n * Adds an extension, which adds functionality to Ease components.\n * \n * Extensions should be objects containing:\n * - name: The name of the extension\n * - methods: An object containing methods to be added to Ease\n * - objects: An object containing properties to be added to Ease\n * \n * While Ease Core does not use extensions, they can be used to add functionality\n * to modules that use Ease.\n * \n * @param {*} object The object to be injected\n */\nexport function addExtension(object) {\n  let name = object.name || object.constructor.name\n  config.inject.extensions.push(object)\n  log.info(`Extension '${name}' has been added to Ease`)\n}\n\n/* Print to the console if debug mode is enabled */\nif (config.core.debug) log.info('Ease Loaded in Debug Mode');\n\n/* Export Ease */\nglobalThis.ease = { config, addExtension, log }"],
  "mappings": "gGAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,WAAAE,EAAA,SAAAC,EAAA,QAAAC,EAAA,SAAAC,IAEO,SAASC,KAASC,EAAM,CACxBC,EAAO,MAAM,QAClB,QAAQ,MAAM,eAAe,EAC7B,QAAQ,MAAM,GAAGD,CAAI,EACrB,QAAQ,SAAS,EACnB,CAEO,SAASE,KAAQF,EAAM,CACvBC,EAAO,MAAM,QAClB,QAAQ,MAAM,cAAc,EAC5B,QAAQ,KAAK,GAAGD,CAAI,EACpB,QAAQ,SAAS,EACnB,CAEO,SAASG,KAAOH,EAAM,CACtBC,EAAO,MAAM,QAClB,QAAQ,MAAM,aAAa,EAC3B,QAAQ,IAAI,GAAGD,CAAI,EACnB,QAAQ,SAAS,EACnB,CAEO,SAASI,KAAQJ,EAAM,CACxB,CAACC,EAAO,MAAM,OAASA,EAAO,KAAK,QAAU,YACjD,QAAQ,MAAM,OAAO,EACrB,QAAQ,KAAK,GAAGD,CAAI,EACpB,QAAQ,SAAS,EACnB,CCbA,IAAIK,EAAU,IAAI,YACdC,EAAkB,CAAC,EAKjBC,EAAN,cAA+B,WAAY,CACzC,YAAYC,EAAMC,EAAM,CACtB,MAAM,iBAAiBD,CAAI,GAAI,CAAE,OAAQ,CAAE,KAAAC,CAAK,CAAE,CAAC,CACrD,CACF,EAQMC,EAAN,cAAoC,WAAY,CAC9C,YAAYF,EAAMG,EAAU,CAC1B,IAAIC,EAAQD,EACV,gCAAgCH,CAAI,GACpC,+BAA+BA,CAAI,GACrC,MAAMI,EAAO,CAAE,OAAQ,CAAE,SAAAD,CAAS,CAAE,CAAC,CACvC,CACF,EAOO,SAASE,EAAKL,EAAMC,EAAM,CAC/BJ,EAAQ,cAAc,IAAIE,EAAiBC,EAAMC,CAAI,CAAC,CACxD,CAQO,SAASK,EAAGN,EAAMO,EAAU,CACjC,OAAAV,EAAQ,iBAAiB,iBAAiBG,CAAI,GAAKQ,GAAU,CAC3DD,IAAWC,EAAM,OAAO,IAAI,CAC9B,CAAC,EACM,CACL,IAAK,IAAMX,EAAQ,oBAAoB,oBAAqBU,CAAQ,CACtE,CACF,CAQO,SAASE,EAAQT,EAAMG,EAAU,CACtC,OAAAL,EAAgB,KAAKE,CAAI,EACzBH,EAAQ,iBAAiB,gCAAgCG,CAAI,GAAKQ,GAAU,CACtE,OAAOL,GAAa,WACtBN,EAAQ,cAAc,IAAIK,EAAsBF,EAAMG,CAAQ,CAAC,EACtD,OAAOA,GAAa,UAC7BN,EAAQ,cAAc,IAAIK,EAAsBF,EAAM,EAAI,CAAC,EAClD,OAAOG,EAAa,IAC7BO,EAAM,+EAA+E,EAErFb,EAAQ,cAAc,IAAIK,EAAsBF,EAAMG,CAAQ,CAAC,CAEnE,CAAC,EACM,CACL,IAAK,IAAM,CACTL,EAAkBA,EAAgB,OAAQa,GAAOA,IAAOX,CAAI,EAC5DH,EAAQ,oBAAoB,0BAA2B,QAAQ,CACjE,CACF,CACF,CAOO,SAASe,EAAKZ,EAAMO,EAAU,CACnC,OAAOD,EAAGN,EAAOC,GAAS,CACxB,QAAQ,IAAI,EACZM,EAASN,CAAI,CACf,CAAC,CACH,CAOO,SAASY,EAAMb,EAAM,CAC1B,OAAO,IAAI,QAAQ,CAACc,EAASC,IAAW,CACjCjB,EAAgB,SAASE,CAAI,IAChCU,EAAM,+BAA+BV,CAAI,GAAG,EAC5Ce,EAAO,GAGTlB,EAAQ,iBAAiB,gCAAgCG,CAAI,GAAKQ,GAAU,CAC1EM,EAAQN,EAAM,OAAO,QAAQ,CAC/B,CAAC,EAEDX,EAAQ,cAAc,IAAIK,EAAsBF,CAAI,CAAC,CACvD,CAAC,CACH,CAMA,WAAW,YAAc,CAAE,KAAAK,EAAM,GAAAC,EAAI,QAAAG,EAAS,KAAAG,EAAM,MAAAC,CAAM,EC5HnD,IAAIG,EAAS,CAClB,KAAM,CACJ,MAAO,EACT,EACA,OAAQ,CACN,KAAM,IACN,WAAY,CAAC,CACf,CACF,EAGA,SAAS,iBAAiB,MAAM,GAAG,QAASC,GAAS,CACnD,GAAIA,EAAK,KAAK,WAAW,OAAO,EAAG,CACjC,IAAIC,EAAOD,EAAK,KAAK,QAAQ,QAAS,EAAE,EAAE,MAAM,GAAG,EAC/CE,EAAMD,EAAK,IAAI,EAEfE,EAASF,EAAK,OAAO,CAACG,EAAIF,KACxBE,EAAIF,CAAG,IAAM,SAAWE,EAAIF,CAAG,EAAI,CAAC,GACjCE,EAAIF,CAAG,GACbH,CAAM,EAETI,EAAOD,CAAG,EAAIF,EAAK,OACrB,CACF,CAAC,EAeM,SAASK,EAAaC,EAAQ,CACnC,IAAIC,EAAOD,EAAO,MAAQA,EAAO,YAAY,KAC7CP,EAAO,OAAO,WAAW,KAAKO,CAAM,EAChCE,EAAK,cAAcD,CAAI,0BAA0B,CACvD,CAGIR,EAAO,KAAK,OAAWS,EAAK,2BAA2B,EAG3D,WAAW,KAAO,CAAE,OAAAT,EAAQ,aAAAM,EAAc,IAAAI,CAAI",
  "names": ["log_exports", "__export", "error", "info", "log", "warn", "error", "data", "config", "warn", "log", "info", "emitter", "fetchHandlerIds", "EventBridgeEvent", "name", "data", "EventBridgeFetchEvent", "response", "_name", "send", "on", "callback", "event", "onFetch", "error", "id", "once", "fetch", "resolve", "reject", "config", "meta", "path", "key", "target", "acc", "addExtension", "object", "name", "info", "log_exports"]
}
